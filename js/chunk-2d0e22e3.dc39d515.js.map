{"version":3,"sources":["webpack:///./src/views/bioInfo/Bio-venn.vue","webpack:///./src/utils/vennUtil.js","webpack:///./src/views/bioInfo/Bio-venn.vue?4bc9"],"names":["id","SMALL","circleArea","r","width","Math","acos","sqrt","getCenter","points","center","x","y","i","length","distance","p1","p2","containedInCircles","point","circles","radius","intersectionArea","stats","intersectionPoints","getIntersectionPoints","innerPoints","filter","p","arcArea","polygonArea","arcs","angle","atan2","sort","a","b","midPoint","arc","j","parentIndex","indexOf","circle","a1","a2","angleDiff","PI","sin","cos","push","smallest","disjoint","abs","area","ret","intersect","circleCircleIntersection","k","circleOverlap","r1","r2","d","min","w1","w2","h","x0","y0","rx","ry","bisect","f","parameters","maxIterations","tolerance","fA","fB","delta","mid","fMid","zeros","Array","zerosM","map","dot","norm2","scale","value","c","weightedSum","v1","v2","nelderMead","nonZeroDelta","zeroDelta","minErrorDelta","minTolerance","rho","undefined","chi","psi","sigma","maxDiff","N","simplex","fx","slice","updateSimplex","sortOrder","centroid","reflected","contracted","expanded","iteration","history","sortedSimplex","state","max","worst","shouldReduce","wolfeLineSearch","pk","current","next","c1","c2","phi0","phiPrime0","fxprime","phi","phi_old","phiPrime","a0","zoom","a_lo","a_high","phi_lo","conjugateGradient","initial","params","yk","temp","alpha","delta_k","beta_k","venn","areas","initialLayout","bestInitialLayout","loss","lossFunction","addMissingAreas","setids","setid","hasOwnProperty","solution","values","positions","SMALL$1","distanceFromIntersectArea","overlap","distance$$1","ids","pairs","sets","size","getDistanceMatrices","distances","constraints","left","right","constrainedMDSGradient","xi","yi","xj","yj","dij","constraint","squaredDistance","greedyLayout","constrained","constrainedMDSLayout","constrainedLoss","greedyLoss","restarts","matrices","norm","row","obj","best","random","set","setOverlaps","rowid","weight","mostOverlapped","positioned","isPositioned","element","positionSet","index","setIndex","d1","d2","extraPoints","l","bestLoss","bestPoint","localLoss","overlaps","output","getCircles","indices","orientateCircles","orientation","orientationOrder","largestX","largestY","dist","rotation","s","slope","disjointCluster","find","parent","union","xRoot","yRoot","maxDistance","disjointClusters","getBoundingBox","minMax","hi","apply","lo","xRange","yRange","normalizeSolution","previous","clusters","bounds","returnBounds","spacing","addCluster","cluster","bottom","xOffset","yOffset","centreing","scaleSolution","height","padding","console","log","xScaling","yScaling","scaling","scaled","VennDiagram","duration","normalize","wrap","styled","fontSize","colourMap","colourScheme","colourIndex","colours","key","layoutFunction","chart","selection","data","datum","toremove","forEach","some","textCentres","computeTextCentres","labels","label","selectAll","enter","append","svg","select","attr","hasPrevious","each","path","d3","this","circleFromPath","pathTween","t","start","end","intersectionAreaPath","nodes","join","enterPath","enterText","text","style","update","transition","attrTween","updateText","floor","on","wrapText","exit","remove","exitText","_","arguments","labeller","words","split","reverse","maxLines","minChars","joined","word","pop","line","lineNumber","lineHeight","tspan","node","getComputedTextLength","circleMargin","interior","exterior","m","margin","computeTextCentre","valid","areaStats","getOverlappingCircles","circleids","circleid","overlapped","areaids","exclude","centre","circlePath","tokens","parseFloat","wide","name","div","call","render","__scopeId"],"mappings":"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","file":"js/chunk-2d0e22e3.dc39d515.js","sourcesContent":["<template>\n  <div id='svg-contrainer'>\n\n  </div>\n</template>\n\n<script>\nimport { defineComponent, onMounted } from 'vue'\nimport * as d3 from 'd3'\nimport { VennDiagram } from '@/utils/vennUtil.js'\n\nexport default defineComponent({\n  name: 'Bio-venn',\n  setup () {\n    onMounted(() => {\n      const sets = [\n        { sets: ['Information'], size: 12 },\n        { sets: ['Things That Overlap'], size: 12 },\n        { sets: ['Circles'], size: 12 },\n        { sets: ['Information', 'Things That Overlap'], size: 4, label: 'Redundancy' },\n        { sets: ['Information', 'Circles'], size: 4, label: 'Pie Charts' },\n        { sets: ['Things That Overlap', 'Circles'], size: 4, label: 'Eclipses' },\n        { sets: ['Information', 'Things That Overlap', 'Circles'], size: 2, label: 'Venn Diagrams' }\n      ]\n\n      const chart = VennDiagram()\n      chart.wrap(false)\n        .width(640)\n        .height(640)\n\n      const div = d3.select('#svg-contrainer').datum(sets).call(chart)\n      div.selectAll('text').style('fill', 'white')\n      div.selectAll('.venn-circle path').style('fill-opacity', 0.6)\n    })\n  }\n\n})\n</script>\n\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped lang=\"scss\">\n</style>\n","/* eslint-disable no-throw-literal */\n/* eslint-disable no-prototype-builtins */\n/* eslint-disable @typescript-eslint/no-use-before-define */\n/* eslint-disable no-var */\n/* eslint-disable eqeqeq */\n/* eslint-disable @typescript-eslint/camelcase */\nimport * as d3 from 'd3'\n\nconst SMALL = 1e-10\n\n/** Circular segment area calculation. See http://mathworld.wolfram.com/CircularSegment.html */\nfunction circleArea(r, width) {\n  return (\n    r * r * Math.acos(1 - width / r) -\n    (r - width) * Math.sqrt(width * (2 * r - width))\n  )\n}\n\n/** Returns the center of a bunch of points */\nfunction getCenter(points) {\n  const center = { x: 0, y: 0 }\n  for (let i = 0; i < points.length; ++i) {\n    center.x += points[i].x\n    center.y += points[i].y\n  }\n  center.x /= points.length\n  center.y /= points.length\n  return center\n}\n\nfunction distance(p1, p2) {\n  return Math.sqrt(\n    (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y)\n  )\n}\n/** returns whether a point is contained by all of a list of circles */\nfunction containedInCircles(point, circles) {\n  for (let i = 0; i < circles.length; ++i) {\n    if (distance(point, circles[i]) > circles[i].radius + SMALL) {\n      return false\n    }\n  }\n  return true\n}\n\n/** Returns the intersection area of a bunch of circles (where each circle\n is an object having an x,y and radius property) */\nfunction intersectionArea(circles, stats) {\n  // get all the intersection points of the circles\n  const intersectionPoints = getIntersectionPoints(circles)\n\n  // filter out points that aren't included in all the circles\n  const innerPoints = intersectionPoints.filter(function(p) {\n    return containedInCircles(p, circles)\n  })\n\n  let arcArea = 0\n  let polygonArea = 0\n  const arcs = []\n  let i\n\n  // if we have intersection points that are within all the circles,\n  // then figure out the area contained by them\n  if (innerPoints.length > 1) {\n    // sort the points by angle from the center of the polygon, which lets\n    // us just iterate over points to get the edges\n    const center = getCenter(innerPoints)\n    for (i = 0; i < innerPoints.length; ++i) {\n      const p = innerPoints[i]\n      p.angle = Math.atan2(p.x - center.x, p.y - center.y)\n    }\n    innerPoints.sort(function(a, b) {\n      return b.angle - a.angle\n    })\n\n    // iterate over all points, get arc between the points\n    // and update the areas\n    let p2 = innerPoints[innerPoints.length - 1]\n    for (i = 0; i < innerPoints.length; ++i) {\n      const p1 = innerPoints[i]\n\n      // polygon area updates easily ...\n      polygonArea += (p2.x + p1.x) * (p1.y - p2.y)\n\n      // updating the arc area is a little more involved\n      const midPoint = {\n        x: (p1.x + p2.x) / 2,\n        y: (p1.y + p2.y) / 2\n      }\n      let arc = null\n\n      for (let j = 0; j < p1.parentIndex.length; ++j) {\n        if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {\n          // figure out the angle halfway between the two points\n          // on the current circle\n          const circle = circles[p1.parentIndex[j]]\n          const a1 = Math.atan2(p1.x - circle.x, p1.y - circle.y)\n          const a2 = Math.atan2(p2.x - circle.x, p2.y - circle.y)\n\n          let angleDiff = a2 - a1\n          if (angleDiff < 0) {\n            angleDiff += 2 * Math.PI\n          }\n\n          // and use that angle to figure out the width of the\n          // arc\n          const a = a2 - angleDiff / 2\n          let width = distance(midPoint, {\n            x: circle.x + circle.radius * Math.sin(a),\n            y: circle.y + circle.radius * Math.cos(a)\n          })\n\n          // clamp the width to the largest is can actually be\n          // (sometimes slightly overflows because of FP errors)\n          if (width > circle.radius * 2) {\n            width = circle.radius * 2\n          }\n\n          // pick the circle whose arc has the smallest width\n          if (arc === null || arc.width > width) {\n            arc = {\n              circle: circle,\n              width: width,\n              p1: p1,\n              p2: p2\n            }\n          }\n        }\n      }\n\n      if (arc !== null) {\n        arcs.push(arc)\n        arcArea += circleArea(arc.circle.radius, arc.width)\n        p2 = p1\n      }\n    }\n  } else {\n    // no intersection points, is either disjoint - or is completely\n    // overlapped. figure out which by examining the smallest circle\n    let smallest = circles[0]\n    for (i = 1; i < circles.length; ++i) {\n      if (circles[i].radius < smallest.radius) {\n        smallest = circles[i]\n      }\n    }\n\n    // make sure the smallest circle is completely contained in all\n    // the other circles\n    let disjoint = false\n    for (i = 0; i < circles.length; ++i) {\n      if (\n        distance(circles[i], smallest) >\n        Math.abs(smallest.radius - circles[i].radius)\n      ) {\n        disjoint = true\n        break\n      }\n    }\n\n    if (disjoint) {\n      arcArea = polygonArea = 0\n    } else {\n      arcArea = smallest.radius * smallest.radius * Math.PI\n      arcs.push({\n        circle: smallest,\n        p1: { x: smallest.x, y: smallest.y + smallest.radius },\n        p2: { x: smallest.x - SMALL, y: smallest.y + smallest.radius },\n        width: smallest.radius * 2\n      })\n    }\n  }\n\n  polygonArea /= 2\n  if (stats) {\n    stats.area = arcArea + polygonArea\n    stats.arcArea = arcArea\n    stats.polygonArea = polygonArea\n    stats.arcs = arcs\n    stats.innerPoints = innerPoints\n    stats.intersectionPoints = intersectionPoints\n  }\n\n  return arcArea + polygonArea\n}\n\n/** Gets all intersection points between a bunch of circles */\nfunction getIntersectionPoints(circles) {\n  const ret = []\n  for (let i = 0; i < circles.length; ++i) {\n    for (let j = i + 1; j < circles.length; ++j) {\n      const intersect = circleCircleIntersection(circles[i], circles[j])\n      for (let k = 0; k < intersect.length; ++k) {\n        const p = intersect[k]\n        p.parentIndex = [i, j]\n        ret.push(p)\n      }\n    }\n  }\n  return ret\n}\n\n/** euclidean distance between two points */\n\n/** Returns the overlap area of two circles of radius r1 and r2 - that\nhave their centers separated by distance d. Simpler faster\ncircle intersection for only two circles */\nfunction circleOverlap(r1, r2, d) {\n  // no overlap\n  if (d >= r1 + r2) {\n    return 0\n  }\n\n  // completely overlapped\n  if (d <= Math.abs(r1 - r2)) {\n    return Math.PI * Math.min(r1, r2) * Math.min(r1, r2)\n  }\n\n  const w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d)\n  const w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d)\n  return circleArea(r1, w1) + circleArea(r2, w2)\n}\n\n/** Given two circles (containing a x/y/radius attributes),\nreturns the intersecting points if possible.\nnote: doesn't handle cases where there are infinitely many\nintersection points (circles are equivalent):, or only one intersection point */\nfunction circleCircleIntersection(p1, p2) {\n  const d = distance(p1, p2)\n  const r1 = p1.radius\n  const r2 = p2.radius\n\n  // if to far away, or self contained - can't be done\n  if (d >= r1 + r2 || d <= Math.abs(r1 - r2)) {\n    return []\n  }\n\n  const a = (r1 * r1 - r2 * r2 + d * d) / (2 * d)\n  const h = Math.sqrt(r1 * r1 - a * a)\n  const x0 = p1.x + (a * (p2.x - p1.x)) / d\n  const y0 = p1.y + (a * (p2.y - p1.y)) / d\n  const rx = -(p2.y - p1.y) * (h / d)\n  const ry = -(p2.x - p1.x) * (h / d)\n\n  return [\n    { x: x0 + rx, y: y0 - ry },\n    { x: x0 - rx, y: y0 + ry }\n  ]\n}\n\n/** finds the zeros of a function, given two starting points (which must\n * have opposite signs */\nfunction bisect(f, a, b, parameters) {\n  parameters = parameters || {}\n  const maxIterations = parameters.maxIterations || 100\n  const tolerance = parameters.tolerance || 1e-10\n  const fA = f(a)\n  const fB = f(b)\n  let delta = b - a\n\n  if (fA * fB > 0) {\n    throw 'Initial bisect points must have opposite signs'\n  }\n\n  if (fA === 0) return a\n  if (fB === 0) return b\n\n  for (let i = 0; i < maxIterations; ++i) {\n    delta /= 2\n    const mid = a + delta\n    const fMid = f(mid)\n\n    if (fMid * fA >= 0) {\n      a = mid\n    }\n\n    if (Math.abs(delta) < tolerance || fMid === 0) {\n      return mid\n    }\n  }\n  return a + delta\n}\n\n// need some basic operations on vectors, rather than adding a dependency,\n// just define here\nfunction zeros(x) {\n  const r = new Array(x)\n  for (let i = 0; i < x; ++i) {\n    r[i] = 0\n  }\n  return r\n}\nfunction zerosM(x, y) {\n  return zeros(x).map(function() {\n    return zeros(y)\n  })\n}\n\nfunction dot(a, b) {\n  let ret = 0\n  for (let i = 0; i < a.length; ++i) {\n    ret += a[i] * b[i]\n  }\n  return ret\n}\n\nfunction norm2(a) {\n  return Math.sqrt(dot(a, a))\n}\n\nfunction scale(ret, value, c) {\n  for (let i = 0; i < value.length; ++i) {\n    ret[i] = value[i] * c\n  }\n}\n\nfunction weightedSum(ret, w1, v1, w2, v2) {\n  for (let j = 0; j < ret.length; ++j) {\n    ret[j] = w1 * v1[j] + w2 * v2[j]\n  }\n}\n\n/** minimizes a function using the downhill simplex method */\nfunction nelderMead(f, x0, parameters) {\n  parameters = parameters || {}\n\n  const maxIterations = parameters.maxIterations || x0.length * 200\n  const nonZeroDelta = parameters.nonZeroDelta || 1.05\n  const zeroDelta = parameters.zeroDelta || 0.001\n  const minErrorDelta = parameters.minErrorDelta || 1e-6\n  const minTolerance = parameters.minErrorDelta || 1e-5\n  const rho = parameters.rho !== undefined ? parameters.rho : 1\n  const chi = parameters.chi !== undefined ? parameters.chi : 2\n  const psi = parameters.psi !== undefined ? parameters.psi : -0.5\n  const sigma = parameters.sigma !== undefined ? parameters.sigma : 0.5\n  let maxDiff\n\n  // initialize simplex.\n  const N = x0.length\n  const simplex = new Array(N + 1)\n  simplex[0] = x0\n  simplex[0].fx = f(x0)\n  simplex[0].id = 0\n  for (var i = 0; i < N; ++i) {\n    const point = x0.slice()\n    point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta\n    simplex[i + 1] = point\n    simplex[i + 1].fx = f(point)\n    simplex[i + 1].id = i + 1\n  }\n\n  function updateSimplex(value) {\n    for (let i = 0; i < value.length; i++) {\n      simplex[N][i] = value[i]\n    }\n    simplex[N].fx = value.fx\n  }\n\n  const sortOrder = function(a, b) {\n    return a.fx - b.fx\n  }\n\n  const centroid = x0.slice()\n  const reflected = x0.slice()\n  const contracted = x0.slice()\n  const expanded = x0.slice()\n\n  for (let iteration = 0; iteration < maxIterations; ++iteration) {\n    simplex.sort(sortOrder)\n\n    if (parameters.history) {\n      // copy the simplex (since later iterations will mutate) and\n      // sort it to have a consistent order between iterations\n      const sortedSimplex = simplex.map(function(x) {\n        const state = x.slice()\n        state.fx = x.fx\n        state.id = x.id\n        return state\n      })\n      sortedSimplex.sort(function(a, b) {\n        return a.id - b.id\n      })\n\n      parameters.history.push({\n        x: simplex[0].slice(),\n        fx: simplex[0].fx,\n        simplex: sortedSimplex\n      })\n    }\n\n    maxDiff = 0\n    for (i = 0; i < N; ++i) {\n      maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]))\n    }\n\n    if (\n      Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta &&\n      maxDiff < minTolerance\n    ) {\n      break\n    }\n\n    // compute the centroid of all but the worst point in the simplex\n    for (i = 0; i < N; ++i) {\n      centroid[i] = 0\n      for (let j = 0; j < N; ++j) {\n        centroid[i] += simplex[j][i]\n      }\n      centroid[i] /= N\n    }\n\n    // reflect the worst point past the centroid  and compute loss at reflected\n    // point\n    const worst = simplex[N]\n    weightedSum(reflected, 1 + rho, centroid, -rho, worst)\n    reflected.fx = f(reflected)\n\n    // if the reflected point is the best seen, then possibly expand\n    if (reflected.fx < simplex[0].fx) {\n      weightedSum(expanded, 1 + chi, centroid, -chi, worst)\n      expanded.fx = f(expanded)\n      if (expanded.fx < reflected.fx) {\n        updateSimplex(expanded)\n      } else {\n        updateSimplex(reflected)\n      }\n    } else if (reflected.fx >= simplex[N - 1].fx) {\n      // if the reflected point is worse than the second worst, we need to\n      // contract\n      let shouldReduce = false\n\n      if (reflected.fx > worst.fx) {\n        // do an inside contraction\n        weightedSum(contracted, 1 + psi, centroid, -psi, worst)\n        contracted.fx = f(contracted)\n        if (contracted.fx < worst.fx) {\n          updateSimplex(contracted)\n        } else {\n          shouldReduce = true\n        }\n      } else {\n        // do an outside contraction\n        weightedSum(contracted, 1 - psi * rho, centroid, psi * rho, worst)\n        contracted.fx = f(contracted)\n        if (contracted.fx < reflected.fx) {\n          updateSimplex(contracted)\n        } else {\n          shouldReduce = true\n        }\n      }\n\n      if (shouldReduce) {\n        // if we don't contract here, we're done\n        if (sigma >= 1) break\n\n        // do a reduction\n        for (i = 1; i < simplex.length; ++i) {\n          weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i])\n          simplex[i].fx = f(simplex[i])\n        }\n      }\n    } else {\n      updateSimplex(reflected)\n    }\n  }\n\n  simplex.sort(sortOrder)\n  return {\n    fx: simplex[0].fx,\n    x: simplex[0]\n  }\n}\n\n/// searches along line 'pk' for a point that satifies the wolfe conditions\n/// See 'Numerical Optimization' by Nocedal and Wright p59-60\n/// f : objective function\n/// pk : search direction\n/// current: object containing current gradient/loss\n/// next: output: contains next gradient/loss\n/// returns a: step size taken\nfunction wolfeLineSearch(f, pk, current, next, a, c1, c2) {\n  const phi0 = current.fx\n  const phiPrime0 = dot(current.fxprime, pk)\n  let phi = phi0\n  let phi_old = phi0\n  let phiPrime = phiPrime0\n  let a0 = 0\n\n  a = a || 1\n  c1 = c1 || 1e-6\n  c2 = c2 || 0.1\n\n  function zoom(a_lo, a_high, phi_lo) {\n    for (let iteration = 0; iteration < 16; ++iteration) {\n      a = (a_lo + a_high) / 2\n      weightedSum(next.x, 1.0, current.x, a, pk)\n      phi = next.fx = f(next.x, next.fxprime)\n      phiPrime = dot(next.fxprime, pk)\n\n      if (phi > phi0 + c1 * a * phiPrime0 || phi >= phi_lo) {\n        a_high = a\n      } else {\n        if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n          return a\n        }\n\n        if (phiPrime * (a_high - a_lo) >= 0) {\n          a_high = a_lo\n        }\n\n        a_lo = a\n        phi_lo = phi\n      }\n    }\n\n    return 0\n  }\n\n  for (let iteration = 0; iteration < 10; ++iteration) {\n    weightedSum(next.x, 1.0, current.x, a, pk)\n    phi = next.fx = f(next.x, next.fxprime)\n    phiPrime = dot(next.fxprime, pk)\n    if (phi > phi0 + c1 * a * phiPrime0 || (iteration && phi >= phi_old)) {\n      return zoom(a0, a, phi_old)\n    }\n\n    if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n      return a\n    }\n\n    if (phiPrime >= 0) {\n      return zoom(a, a0, phi)\n    }\n\n    phi_old = phi\n    a0 = a\n    a *= 2\n  }\n\n  return a\n}\n\nfunction conjugateGradient(f, initial, params) {\n  // allocate all memory up front here, keep out of the loop for perfomance\n  // reasons\n  let current = { x: initial.slice(), fx: 0, fxprime: initial.slice() }\n  let next = { x: initial.slice(), fx: 0, fxprime: initial.slice() }\n  const yk = initial.slice()\n  let temp\n  let a = 1\n\n  params = params || {}\n  const maxIterations = params.maxIterations || initial.length * 20\n\n  current.fx = f(current.x, current.fxprime)\n  const pk = current.fxprime.slice()\n  scale(pk, current.fxprime, -1)\n\n  for (let i = 0; i < maxIterations; ++i) {\n    a = wolfeLineSearch(f, pk, current, next, a)\n\n    // todo: history in wrong spot?\n    if (params.history) {\n      params.history.push({\n        x: current.x.slice(),\n        fx: current.fx,\n        fxprime: current.fxprime.slice(),\n        alpha: a\n      })\n    }\n\n    if (!a) {\n      // faiiled to find point that satifies wolfe conditions.\n      // reset direction for next iteration\n      scale(pk, current.fxprime, -1)\n    } else {\n      // update direction using PolakRibiere CG method\n      weightedSum(yk, 1, next.fxprime, -1, current.fxprime)\n\n      const delta_k = dot(current.fxprime, current.fxprime)\n      const beta_k = Math.max(0, dot(yk, next.fxprime) / delta_k)\n\n      weightedSum(pk, beta_k, pk, -1, next.fxprime)\n\n      temp = current\n      current = next\n      next = temp\n    }\n\n    if (norm2(current.fxprime) <= 1e-5) {\n      break\n    }\n  }\n\n  if (params.history) {\n    params.history.push({\n      x: current.x.slice(),\n      fx: current.fx,\n      fxprime: current.fxprime.slice(),\n      alpha: a\n    })\n  }\n\n  return current\n}\n\n/** given a list of set objects, and their corresponding overlaps.\nupdates the (x, y, radius) attribute on each set such that their positions\nroughly correspond to the desired overlaps */\nfunction venn(areas, parameters) {\n  parameters = parameters || {}\n  parameters.maxIterations = parameters.maxIterations || 500\n  const initialLayout = parameters.initialLayout || bestInitialLayout\n  const loss = parameters.lossFunction || lossFunction\n\n  // add in missing pairwise areas as having 0 size\n  areas = addMissingAreas(areas)\n\n  // initial layout is done greedily\n  const circles = initialLayout(areas, parameters)\n\n  // transform x/y coordinates to a vector to optimize\n  const initial = []\n  const setids = []\n  let setid\n  for (setid in circles) {\n    if (circles.hasOwnProperty(setid)) {\n      initial.push(circles[setid].x)\n      initial.push(circles[setid].y)\n      setids.push(setid)\n    }\n  }\n  const solution = nelderMead(\n    function(values) {\n      const current = {}\n      for (let i = 0; i < setids.length; ++i) {\n        const setid = setids[i]\n        current[setid] = {\n          x: values[2 * i],\n          y: values[2 * i + 1],\n          radius: circles[setid].radius\n          // size : circles[setid].size\n        }\n      }\n      return loss(current, areas)\n    },\n    initial,\n    parameters\n  )\n\n  // transform solution vector back to x/y points\n  const positions = solution.x\n  for (let i = 0; i < setids.length; ++i) {\n    setid = setids[i]\n    circles[setid].x = positions[2 * i]\n    circles[setid].y = positions[2 * i + 1]\n  }\n\n  return circles\n}\n\nconst SMALL$1 = 1e-10\n\n/** Returns the distance necessary for two circles of radius r1 + r2 to\nhave the overlap area 'overlap' */\nfunction distanceFromIntersectArea(r1, r2, overlap) {\n  // handle complete overlapped circles\n  if (Math.min(r1, r2) * Math.min(r1, r2) * Math.PI <= overlap + SMALL$1) {\n    return Math.abs(r1 - r2)\n  }\n\n  return bisect(\n    function(distance$$1) {\n      return circleOverlap(r1, r2, distance$$1) - overlap\n    },\n    0,\n    r1 + r2\n  )\n}\n\n/** Missing pair-wise intersection area data can cause problems:\n treating as an unknown means that sets will be laid out overlapping,\n which isn't what people expect. To reflect that we want disjoint sets\n here, set the overlap to 0 for all missing pairwise set intersections */\nfunction addMissingAreas(areas) {\n  areas = areas.slice()\n\n  // two circle intersections that aren't defined\n  const ids = []\n  const pairs = {}\n  let i\n  let j\n  let a\n  let b\n  for (i = 0; i < areas.length; ++i) {\n    const area = areas[i]\n    if (area.sets.length == 1) {\n      ids.push(area.sets[0])\n    } else if (area.sets.length == 2) {\n      a = area.sets[0]\n      b = area.sets[1]\n      pairs[[a, b]] = true\n      pairs[[b, a]] = true\n    }\n  }\n  ids.sort(function(a, b) {\n    return a > b\n  })\n\n  for (i = 0; i < ids.length; ++i) {\n    a = ids[i]\n    for (j = i + 1; j < ids.length; ++j) {\n      b = ids[j]\n      if (!([a, b] in pairs)) {\n        areas.push({\n          sets: [a, b],\n          size: 0\n        })\n      }\n    }\n  }\n  return areas\n}\n\n/// Returns two matrices, one of the euclidean distances between the sets\n/// and the other indicating if there are subset or disjoint set relationships\nfunction getDistanceMatrices(areas, sets, setids) {\n  // initialize an empty distance matrix between all the points\n  const distances = zerosM(sets.length, sets.length)\n  const constraints = zerosM(sets.length, sets.length)\n\n  // compute required distances between all the sets such that\n  // the areas match\n  areas\n    .filter(function(x) {\n      return x.sets.length == 2\n    })\n    .map(function(current) {\n      const left = setids[current.sets[0]]\n      const right = setids[current.sets[1]]\n      const r1 = Math.sqrt(sets[left].size / Math.PI)\n      const r2 = Math.sqrt(sets[right].size / Math.PI)\n      const distance$$1 = distanceFromIntersectArea(r1, r2, current.size)\n\n      distances[left][right] = distances[right][left] = distance$$1\n\n      // also update constraints to indicate if its a subset or disjoint\n      // relationship\n      let c = 0\n      if (current.size + 1e-10 >= Math.min(sets[left].size, sets[right].size)) {\n        c = 1\n      } else if (current.size <= 1e-10) {\n        c = -1\n      }\n      constraints[left][right] = constraints[right][left] = c\n    })\n\n  return { distances: distances, constraints: constraints }\n}\n\n/// computes the gradient and loss simulatenously for our constrained MDS optimizer\nfunction constrainedMDSGradient(x, fxprime, distances, constraints) {\n  let loss = 0\n  let i\n  for (i = 0; i < fxprime.length; ++i) {\n    fxprime[i] = 0\n  }\n\n  for (i = 0; i < distances.length; ++i) {\n    const xi = x[2 * i]\n    const yi = x[2 * i + 1]\n    for (let j = i + 1; j < distances.length; ++j) {\n      const xj = x[2 * j]\n      const yj = x[2 * j + 1]\n      const dij = distances[i][j]\n      const constraint = constraints[i][j]\n\n      const squaredDistance = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi)\n      const distance$$1 = Math.sqrt(squaredDistance)\n      const delta = squaredDistance - dij * dij\n\n      if (\n        (constraint > 0 && distance$$1 <= dij) ||\n        (constraint < 0 && distance$$1 >= dij)\n      ) {\n        continue\n      }\n\n      loss += 2 * delta * delta\n\n      fxprime[2 * i] += 4 * delta * (xi - xj)\n      fxprime[2 * i + 1] += 4 * delta * (yi - yj)\n\n      fxprime[2 * j] += 4 * delta * (xj - xi)\n      fxprime[2 * j + 1] += 4 * delta * (yj - yi)\n    }\n  }\n  return loss\n}\n\n/// takes the best working variant of either constrained MDS or greedy\nfunction bestInitialLayout(areas, params) {\n  let initial = greedyLayout(areas, params)\n  const loss = params.lossFunction || lossFunction\n\n  // greedylayout is sufficient for all 2/3 circle cases. try out\n  // constrained MDS for higher order problems, take its output\n  // if it outperforms. (greedy is aesthetically better on 2/3 circles\n  // since it axis aligns)\n  if (areas.length >= 8) {\n    const constrained = constrainedMDSLayout(areas, params)\n    const constrainedLoss = loss(constrained, areas)\n    const greedyLoss = loss(initial, areas)\n\n    if (constrainedLoss + 1e-8 < greedyLoss) {\n      initial = constrained\n    }\n  }\n  return initial\n}\n\n/// use the constrained MDS variant to generate an initial layout\nfunction constrainedMDSLayout(areas, params) {\n  params = params || {}\n  const restarts = params.restarts || 10\n\n  // bidirectionally map sets to a rowid  (so we can create a matrix)\n  const sets = []\n  const setids = {}\n  let i\n  for (i = 0; i < areas.length; ++i) {\n    const area = areas[i]\n    if (area.sets.length == 1) {\n      setids[area.sets[0]] = sets.length\n      sets.push(area)\n    }\n  }\n\n  const matrices = getDistanceMatrices(areas, sets, setids)\n  let distances = matrices.distances\n  const constraints = matrices.constraints\n\n  // keep distances bounded, things get messed up otherwise.\n  // TODO: proper preconditioner?\n  const norm = norm2(distances.map(norm2)) / distances.length\n  distances = distances.map(function(row) {\n    return row.map(function(value) {\n      return value / norm\n    })\n  })\n\n  const obj = function(x, fxprime) {\n    return constrainedMDSGradient(x, fxprime, distances, constraints)\n  }\n\n  let best, current\n  for (i = 0; i < restarts; ++i) {\n    const initial = zeros(distances.length * 2).map(Math.random)\n\n    current = conjugateGradient(obj, initial, params)\n    if (!best || current.fx < best.fx) {\n      best = current\n    }\n  }\n  const positions = best.x\n\n  // translate rows back to (x,y,radius) coordinates\n  const circles = {}\n  for (i = 0; i < sets.length; ++i) {\n    const set = sets[i]\n    circles[set.sets[0]] = {\n      x: positions[2 * i] * norm,\n      y: positions[2 * i + 1] * norm,\n      radius: Math.sqrt(set.size / Math.PI)\n    }\n  }\n\n  if (params.history) {\n    for (i = 0; i < params.history.length; ++i) {\n      scale(params.history[i].x, norm)\n    }\n  }\n  return circles\n}\n\n/** Lays out a Venn diagram greedily, going from most overlapped sets to\nleast overlapped, attempting to position each new set such that the\noverlapping areas to already positioned sets are basically right */\nfunction greedyLayout(areas, params) {\n  const loss =\n    params && params.lossFunction ? params.lossFunction : lossFunction\n  // define a circle for each set\n  const circles = {}\n  const setOverlaps = {}\n  let set\n  for (var i = 0; i < areas.length; ++i) {\n    const area = areas[i]\n    if (area.sets.length == 1) {\n      set = area.sets[0]\n      circles[set] = {\n        x: 1e10,\n        y: 1e10,\n        rowid: circles.length,\n        size: area.size,\n        radius: Math.sqrt(area.size / Math.PI)\n      }\n      setOverlaps[set] = []\n    }\n  }\n  areas = areas.filter(function(a) {\n    return a.sets.length == 2\n  })\n\n  // map each set to a list of all the other sets that overlap it\n  for (i = 0; i < areas.length; ++i) {\n    const current = areas[i]\n    let weight = current.hasOwnProperty('weight') ? current.weight : 1.0\n    const left = current.sets[0]\n    const right = current.sets[1]\n\n    // completely overlapped circles shouldn't be positioned early here\n    if (\n      current.size + SMALL$1 >=\n      Math.min(circles[left].size, circles[right].size)\n    ) {\n      weight = 0\n    }\n\n    setOverlaps[left].push({ set: right, size: current.size, weight: weight })\n    setOverlaps[right].push({ set: left, size: current.size, weight: weight })\n  }\n\n  // get list of most overlapped sets\n  const mostOverlapped = []\n  for (set in setOverlaps) {\n    if (setOverlaps.hasOwnProperty(set)) {\n      let size = 0\n      for (i = 0; i < setOverlaps[set].length; ++i) {\n        size += setOverlaps[set][i].size * setOverlaps[set][i].weight\n      }\n\n      mostOverlapped.push({ set: set, size: size })\n    }\n  }\n\n  // sort by size desc\n  function sortOrder(a, b) {\n    return b.size - a.size\n  }\n  mostOverlapped.sort(sortOrder)\n\n  // keep track of what sets have been laid out\n  const positioned = {}\n  function isPositioned(element) {\n    return element.set in positioned\n  }\n\n  // adds a point to the output\n  function positionSet(point, index) {\n    circles[index].x = point.x\n    circles[index].y = point.y\n    positioned[index] = true\n  }\n\n  // add most overlapped set at (0,0)\n  positionSet({ x: 0, y: 0 }, mostOverlapped[0].set)\n\n  // get distances between all points. TODO, necessary?\n  // answer: probably not\n  // var distances = venn.getDistanceMatrices(circles, areas).distances;\n  for (i = 1; i < mostOverlapped.length; ++i) {\n    const setIndex = mostOverlapped[i].set\n    const overlap = setOverlaps[setIndex].filter(isPositioned)\n    set = circles[setIndex]\n    overlap.sort(sortOrder)\n\n    if (overlap.length === 0) {\n      // this shouldn't happen anymore with addMissingAreas\n      throw 'ERROR: missing pairwise overlap information'\n    }\n\n    const points = []\n    for (var j = 0; j < overlap.length; ++j) {\n      // get appropriate distance from most overlapped already added set\n      const p1 = circles[overlap[j].set]\n      const d1 = distanceFromIntersectArea(\n        set.radius,\n        p1.radius,\n        overlap[j].size\n      )\n\n      // sample positions at 90 degrees for maximum aesthetics\n      points.push({ x: p1.x + d1, y: p1.y })\n      points.push({ x: p1.x - d1, y: p1.y })\n      points.push({ y: p1.y + d1, x: p1.x })\n      points.push({ y: p1.y - d1, x: p1.x })\n\n      // if we have at least 2 overlaps, then figure out where the\n      // set should be positioned analytically and try those too\n      for (let k = j + 1; k < overlap.length; ++k) {\n        const p2 = circles[overlap[k].set]\n        const d2 = distanceFromIntersectArea(\n          set.radius,\n          p2.radius,\n          overlap[k].size\n        )\n\n        const extraPoints = circleCircleIntersection(\n          { x: p1.x, y: p1.y, radius: d1 },\n          { x: p2.x, y: p2.y, radius: d2 }\n        )\n\n        for (let l = 0; l < extraPoints.length; ++l) {\n          points.push(extraPoints[l])\n        }\n      }\n    }\n\n    // we have some candidate positions for the set, examine loss\n    // at each position to figure out where to put it at\n    let bestLoss = 1e50\n    let bestPoint = points[0]\n    for (j = 0; j < points.length; ++j) {\n      circles[setIndex].x = points[j].x\n      circles[setIndex].y = points[j].y\n      const localLoss = loss(circles, areas)\n      if (localLoss < bestLoss) {\n        bestLoss = localLoss\n        bestPoint = points[j]\n      }\n    }\n\n    positionSet(bestPoint, setIndex)\n  }\n\n  return circles\n}\n\n/** Given a bunch of sets, and the desired overlaps between these sets - computes\nthe distance from the actual overlaps to the desired overlaps. Note that\nthis method ignores overlaps of more than 2 circles */\nfunction lossFunction(sets, overlaps) {\n  let output = 0\n\n  function getCircles(indices) {\n    return indices.map(function(i) {\n      return sets[i]\n    })\n  }\n\n  for (let i = 0; i < overlaps.length; ++i) {\n    const area = overlaps[i]\n    var overlap\n    if (area.sets.length == 1) {\n      continue\n    } else if (area.sets.length == 2) {\n      const left = sets[area.sets[0]]\n      const right = sets[area.sets[1]]\n      overlap = circleOverlap(left.radius, right.radius, distance(left, right))\n    } else {\n      overlap = intersectionArea(getCircles(area.sets))\n    }\n\n    const weight = area.hasOwnProperty('weight') ? area.weight : 1.0\n    output += weight * (overlap - area.size) * (overlap - area.size)\n  }\n\n  return output\n}\n\n// orientates a bunch of circles to point in orientation\nfunction orientateCircles(circles, orientation, orientationOrder) {\n  if (orientationOrder === null) {\n    circles.sort(function(a, b) {\n      return b.radius - a.radius\n    })\n  } else {\n    circles.sort(orientationOrder)\n  }\n\n  let i\n  // shift circles so largest circle is at (0, 0)\n  if (circles.length > 0) {\n    const largestX = circles[0].x\n    const largestY = circles[0].y\n\n    for (i = 0; i < circles.length; ++i) {\n      circles[i].x -= largestX\n      circles[i].y -= largestY\n    }\n  }\n\n  if (circles.length == 2) {\n    // if the second circle is a subset of the first, arrange so that\n    // it is off to one side. hack for https://github.com/benfred/venn.js/issues/120\n    const dist = distance(circles[0], circles[1])\n    if (dist < Math.abs(circles[1].radius - circles[0].radius)) {\n      circles[1].x =\n        circles[0].x + circles[0].radius - circles[1].radius - 1e-10\n      circles[1].y = circles[0].y\n    }\n  }\n\n  // rotate circles so that second largest is at an angle of 'orientation'\n  // from largest\n  if (circles.length > 1) {\n    const rotation = Math.atan2(circles[1].x, circles[1].y) - orientation\n    const c = Math.cos(rotation)\n    const s = Math.sin(rotation)\n    let x\n    let y\n\n    for (i = 0; i < circles.length; ++i) {\n      x = circles[i].x\n      y = circles[i].y\n      circles[i].x = c * x - s * y\n      circles[i].y = s * x + c * y\n    }\n  }\n\n  // mirror solution if third solution is above plane specified by\n  // first two circles\n  if (circles.length > 2) {\n    let angle = Math.atan2(circles[2].x, circles[2].y) - orientation\n    while (angle < 0) {\n      angle += 2 * Math.PI\n    }\n    while (angle > 2 * Math.PI) {\n      angle -= 2 * Math.PI\n    }\n    if (angle > Math.PI) {\n      const slope = circles[1].y / (1e-10 + circles[1].x)\n      for (i = 0; i < circles.length; ++i) {\n        const d = (circles[i].x + slope * circles[i].y) / (1 + slope * slope)\n        circles[i].x = 2 * d - circles[i].x\n        circles[i].y = 2 * d * slope - circles[i].y\n      }\n    }\n  }\n}\n\nfunction disjointCluster(circles) {\n  // union-find clustering to get disjoint sets\n  circles.map(function(circle) {\n    circle.parent = circle\n  })\n\n  // path compression step in union find\n  function find(circle) {\n    if (circle.parent !== circle) {\n      circle.parent = find(circle.parent)\n    }\n    return circle.parent\n  }\n\n  function union(x, y) {\n    const xRoot = find(x)\n    const yRoot = find(y)\n    xRoot.parent = yRoot\n  }\n\n  // get the union of all overlapping sets\n  for (var i = 0; i < circles.length; ++i) {\n    for (let j = i + 1; j < circles.length; ++j) {\n      const maxDistance = circles[i].radius + circles[j].radius\n      if (distance(circles[i], circles[j]) + 1e-10 < maxDistance) {\n        union(circles[j], circles[i])\n      }\n    }\n  }\n\n  // find all the disjoint clusters and group them together\n  const disjointClusters = {}\n  let setid\n  for (i = 0; i < circles.length; ++i) {\n    setid = find(circles[i]).parent.setid\n    if (!(setid in disjointClusters)) {\n      disjointClusters[setid] = []\n    }\n    disjointClusters[setid].push(circles[i])\n  }\n\n  // cleanup bookkeeping\n  circles.map(function(circle) {\n    delete circle.parent\n  })\n\n  // return in more usable form\n  const ret = []\n  for (setid in disjointClusters) {\n    if (disjointClusters.hasOwnProperty(setid)) {\n      ret.push(disjointClusters[setid])\n    }\n  }\n  return ret\n}\n\nfunction getBoundingBox(circles) {\n  const minMax = function(d) {\n    const hi = Math.max.apply(\n      null,\n      circles.map(function(c) {\n        return c[d] + c.radius\n      })\n    )\n    const lo = Math.min.apply(\n      null,\n      circles.map(function(c) {\n        return c[d] - c.radius\n      })\n    )\n    return { max: hi, min: lo }\n  }\n\n  return { xRange: minMax('x'), yRange: minMax('y') }\n}\n\nfunction normalizeSolution(solution, orientation, orientationOrder) {\n  if (orientation === null) {\n    orientation = Math.PI / 2\n  }\n\n  // work with a list instead of a dictionary, and take a copy so we\n  // don't mutate input\n  let circles = []\n  let i\n  let setid\n  for (setid in solution) {\n    if (solution.hasOwnProperty(setid)) {\n      const previous = solution[setid]\n      circles.push({\n        x: previous.x,\n        y: previous.y,\n        radius: previous.radius,\n        setid: setid\n      })\n    }\n  }\n\n  // get all the disjoint clusters\n  const clusters = disjointCluster(circles)\n\n  // orientate all disjoint sets, get sizes\n  for (i = 0; i < clusters.length; ++i) {\n    orientateCircles(clusters[i], orientation, orientationOrder)\n    const bounds = getBoundingBox(clusters[i])\n    clusters[i].size =\n      (bounds.xRange.max - bounds.xRange.min) *\n      (bounds.yRange.max - bounds.yRange.min)\n    clusters[i].bounds = bounds\n  }\n  clusters.sort(function(a, b) {\n    return b.size - a.size\n  })\n\n  // orientate the largest at 0,0, and get the bounds\n  circles = clusters[0]\n  let returnBounds = circles.bounds\n\n  const spacing = (returnBounds.xRange.max - returnBounds.xRange.min) / 50\n\n  function addCluster(cluster, right, bottom) {\n    if (!cluster) return\n\n    const bounds = cluster.bounds\n    let xOffset\n    let yOffset\n    let centreing\n\n    if (right) {\n      xOffset = returnBounds.xRange.max - bounds.xRange.min + spacing\n    } else {\n      xOffset = returnBounds.xRange.max - bounds.xRange.max\n      centreing =\n        (bounds.xRange.max - bounds.xRange.min) / 2 -\n        (returnBounds.xRange.max - returnBounds.xRange.min) / 2\n      if (centreing < 0) xOffset += centreing\n    }\n\n    if (bottom) {\n      yOffset = returnBounds.yRange.max - bounds.yRange.min + spacing\n    } else {\n      yOffset = returnBounds.yRange.max - bounds.yRange.max\n      centreing =\n        (bounds.yRange.max - bounds.yRange.min) / 2 -\n        (returnBounds.yRange.max - returnBounds.yRange.min) / 2\n      if (centreing < 0) yOffset += centreing\n    }\n\n    for (let j = 0; j < cluster.length; ++j) {\n      cluster[j].x += xOffset\n      cluster[j].y += yOffset\n      circles.push(cluster[j])\n    }\n  }\n\n  let index = 1\n  while (index < clusters.length) {\n    addCluster(clusters[index], true, false)\n    addCluster(clusters[index + 1], false, true)\n    addCluster(clusters[index + 2], true, true)\n    index += 3\n\n    // have one cluster (in top left). lay out next three relative\n    // to it in a grid\n    returnBounds = getBoundingBox(circles)\n  }\n\n  // convert back to solution form\n  const ret = {}\n  for (i = 0; i < circles.length; ++i) {\n    ret[circles[i].setid] = circles[i]\n  }\n  return ret\n}\n\n/** Scales a solution from venn.venn or venn.greedyLayout such that it fits in\na rectangle of width/height - with padding around the borders. also\ncenters the diagram in the available space at the same time */\nfunction scaleSolution(solution, width, height, padding) {\n  const circles = []\n  const setids = []\n  for (const setid in solution) {\n    if (solution.hasOwnProperty(setid)) {\n      setids.push(setid)\n      circles.push(solution[setid])\n    }\n  }\n\n  width -= 2 * padding\n  height -= 2 * padding\n\n  const bounds = getBoundingBox(circles)\n  const xRange = bounds.xRange\n  const yRange = bounds.yRange\n\n  if (xRange.max == xRange.min || yRange.max == yRange.min) {\n    console.log('not scaling solution: zero size detected')\n    return solution\n  }\n\n  const xScaling = width / (xRange.max - xRange.min)\n  const yScaling = height / (yRange.max - yRange.min)\n  const scaling = Math.min(yScaling, xScaling)\n\n  // while we're at it, center the diagram too\n  const xOffset = (width - (xRange.max - xRange.min) * scaling) / 2\n  const yOffset = (height - (yRange.max - yRange.min) * scaling) / 2\n\n  const scaled = {}\n  for (let i = 0; i < circles.length; ++i) {\n    const circle = circles[i]\n    scaled[setids[i]] = {\n      radius: scaling * circle.radius,\n      x: padding + xOffset + (circle.x - xRange.min) * scaling,\n      y: padding + yOffset + (circle.y - yRange.min) * scaling\n    }\n  }\n\n  return scaled\n}\n\n/* global console:true */\n\nfunction VennDiagram() {\n  let width = 600\n  let height = 350\n  let padding = 15\n  let duration = 1000\n  let orientation = Math.PI / 2\n  let normalize = true\n  let wrap = true\n  let styled = true\n  let fontSize = null\n  let orientationOrder = null\n\n  // mimic the behaviour of d3.scale.category10 from the previous\n  // version of d3\n  const colourMap = {}\n\n  // so this is the same as d3.schemeCategory10, which is only defined in d3 4.0\n  // since we can support older versions of d3 as long as we don't force this,\n  // I'm hackily redefining below. TODO: remove this and change to d3.schemeCategory10\n  const colourScheme = [\n    '#1f77b4',\n    '#ff7f0e',\n    '#2ca02c',\n    '#d62728',\n    '#9467bd',\n    '#8c564b',\n    '#e377c2',\n    '#7f7f7f',\n    '#bcbd22',\n    '#17becf'\n  ]\n  let colourIndex = 0\n  let colours = function(key) {\n    if (key in colourMap) {\n      return colourMap[key]\n    }\n    const ret = (colourMap[key] = colourScheme[colourIndex])\n    colourIndex += 1\n    if (colourIndex >= colourScheme.length) {\n      colourIndex = 0\n    }\n    return ret\n  }\n  let layoutFunction = venn\n  let loss = lossFunction\n\n  function chart(selection) {\n    let data = selection.datum()\n\n    // handle 0-sized sets by removing from input\n    const toremove = {}\n    data.forEach(function(datum) {\n      if (datum.size == 0 && datum.sets.length == 1) {\n        toremove[datum.sets[0]] = 1\n      }\n    })\n    data = data.filter(function(datum) {\n      return !datum.sets.some(function(set) {\n        return set in toremove\n      })\n    })\n\n    let circles = {}\n    let textCentres = {}\n\n    if (data.length > 0) {\n      let solution = layoutFunction(data, { lossFunction: loss })\n\n      if (normalize) {\n        solution = normalizeSolution(solution, orientation, orientationOrder)\n      }\n\n      circles = scaleSolution(solution, width, height, padding)\n      textCentres = computeTextCentres(circles, data)\n    }\n\n    // Figure out the current label for each set. These can change\n    // and D3 won't necessarily update (fixes https://github.com/benfred/venn.js/issues/103)\n    const labels = {}\n    data.forEach(function(datum) {\n      if (datum.label) {\n        labels[datum.sets] = datum.label\n      }\n    })\n\n    function label(d) {\n      //   if (d.sets in labels) {\n      //     return labels[d.sets]\n      //   }\n      if (d.sets.length == 1) {\n        return `${d.sets[0]}-${d.size}`\n      }\n      return d.size\n    }\n\n    // create svg if not already existing\n    selection\n      .selectAll('svg')\n      .data([circles])\n      .enter()\n      .append('svg')\n\n    const svg = selection\n      .select('svg')\n      .attr('width', width)\n      .attr('height', height)\n\n    // to properly transition intersection areas, we need the\n    // previous circles locations. load from elements\n    const previous = {}\n    let hasPrevious = false\n    svg.selectAll('.venn-area path').each(function(d) {\n      const path = d3.select(this).attr('d')\n      if (d.sets.length == 1 && path) {\n        hasPrevious = true\n        previous[d.sets[0]] = circleFromPath(path)\n      }\n    })\n\n    // interpolate intersection area paths between previous and\n    // current paths\n    const pathTween = function(d) {\n      return function(t) {\n        const c = d.sets.map(function(set) {\n          let start = previous[set]\n          let end = circles[set]\n          if (!start) {\n            start = { x: width / 2, y: height / 2, radius: 1 }\n          }\n          if (!end) {\n            end = { x: width / 2, y: height / 2, radius: 1 }\n          }\n          return {\n            x: start.x * (1 - t) + end.x * t,\n            y: start.y * (1 - t) + end.y * t,\n            radius: start.radius * (1 - t) + end.radius * t\n          }\n        })\n        return intersectionAreaPath(c)\n      }\n    }\n\n    // update data, joining on the set ids\n    const nodes = svg.selectAll('.venn-area').data(data, function(d) {\n      return d.sets\n    })\n\n    // create new nodes\n    const enter = nodes\n      .enter()\n      .append('g')\n      .attr('class', function(d) {\n        return (\n          'venn-area venn-' + (d.sets.length == 1 ? 'circle' : 'intersection')\n        )\n      })\n      .attr('data-venn-sets', function(d) {\n        return d.sets.join('_')\n      })\n\n    const enterPath = enter.append('path')\n    const enterText = enter\n      .append('text')\n      .attr('class', 'label')\n      .text(function(d) {\n        return label(d)\n      })\n      .attr('text-anchor', 'middle')\n      .attr('dy', '.35em')\n      .attr('x', width / 2)\n      .attr('y', height / 2)\n\n    // apply minimal style if wanted\n    if (styled) {\n      enterPath\n        .style('fill-opacity', '0')\n        .filter(function(d) {\n          return d.sets.length == 1\n        })\n        .style('fill', function(d) {\n          return colours(d.sets)\n        })\n        .style('fill-opacity', '.25')\n\n      enterText.style('fill', function(d) {\n        return d.sets.length == 1 ? colours(d.sets) : '#444'\n      })\n    }\n\n    // update existing, using pathTween if necessary\n    let update = selection\n    if (hasPrevious) {\n      update = selection.transition('venn').duration(duration)\n      update.selectAll('path').attrTween('d', pathTween)\n    } else {\n      update.selectAll('path').attr('d', function(d) {\n        return intersectionAreaPath(\n          d.sets.map(function(set) {\n            return circles[set]\n          })\n        )\n      })\n    }\n\n    const updateText = update\n      .selectAll('text')\n      .filter(function(d) {\n        return d.sets in textCentres\n      })\n      .text(function(d) {\n        return label(d)\n      })\n      .attr('x', function(d) {\n        return Math.floor(textCentres[d.sets].x)\n      })\n      .attr('y', function(d) {\n        return Math.floor(textCentres[d.sets].y)\n      })\n\n    if (wrap) {\n      if (hasPrevious) {\n        // d3 4.0 uses 'on' for events on transitions,\n        // but d3 3.0 used 'each' instead. switch appropiately\n        if ('on' in updateText) {\n          updateText.on('end', wrapText(circles, label))\n        } else {\n          updateText.each('end', wrapText(circles, label))\n        }\n      } else {\n        updateText.each(wrapText(circles, label))\n      }\n    }\n\n    // remove old\n    const exit = nodes\n      .exit()\n      .transition('venn')\n      .duration(duration)\n      .remove()\n    exit.selectAll('path').attrTween('d', pathTween)\n\n    const exitText = exit\n      .selectAll('text')\n      .attr('x', width / 2)\n      .attr('y', height / 2)\n\n    // if we've been passed a fontSize explicitly, use it to\n    // transition\n    if (fontSize !== null) {\n      enterText.style('font-size', '0px')\n      updateText.style('font-size', fontSize)\n      exitText.style('font-size', '0px')\n    }\n\n    return {\n      circles: circles,\n      textCentres: textCentres,\n      nodes: nodes,\n      enter: enter,\n      update: update,\n      exit: exit\n    }\n  }\n\n  chart.wrap = function(_) {\n    if (!arguments.length) return wrap\n    wrap = _\n    return chart\n  }\n\n  chart.width = function(_) {\n    if (!arguments.length) return width\n    width = _\n    return chart\n  }\n\n  chart.height = function(_) {\n    if (!arguments.length) return height\n    height = _\n    return chart\n  }\n\n  chart.padding = function(_) {\n    if (!arguments.length) return padding\n    padding = _\n    return chart\n  }\n\n  chart.colours = function(_) {\n    if (!arguments.length) return colours\n    colours = _\n    return chart\n  }\n\n  chart.fontSize = function(_) {\n    if (!arguments.length) return fontSize\n    fontSize = _\n    return chart\n  }\n\n  chart.duration = function(_) {\n    if (!arguments.length) return duration\n    duration = _\n    return chart\n  }\n\n  chart.layoutFunction = function(_) {\n    if (!arguments.length) return layoutFunction\n    layoutFunction = _\n    return chart\n  }\n\n  chart.normalize = function(_) {\n    if (!arguments.length) return normalize\n    normalize = _\n    return chart\n  }\n\n  chart.styled = function(_) {\n    if (!arguments.length) return styled\n    styled = _\n    return chart\n  }\n\n  chart.orientation = function(_) {\n    if (!arguments.length) return orientation\n    orientation = _\n    return chart\n  }\n\n  chart.orientationOrder = function(_) {\n    if (!arguments.length) return orientationOrder\n    orientationOrder = _\n    return chart\n  }\n\n  chart.lossFunction = function(_) {\n    if (!arguments.length) return loss\n    loss = _\n    return chart\n  }\n\n  return chart\n}\n// sometimes text doesn't fit inside the circle, if thats the case lets wrap\n// the text here such that it fits\n// todo: looks like this might be merged into d3 (\n// https://github.com/mbostock/d3/issues/1642),\n// also worth checking out is\n// http://engineering.findthebest.com/wrapping-axis-labels-in-d3-js/\n// this seems to be one of those things that should be easy but isn't\nfunction wrapText(circles, labeller) {\n  return function() {\n    const text = d3.select(this)\n    const data = text.datum()\n    const width = circles[data.sets[0]].radius || 50\n    const label = labeller(data) || ''\n\n    const words = label.split(/\\s+/).reverse()\n    const maxLines = 3\n    const minChars = (label.length + words.length) / maxLines\n    let word = words.pop()\n    let line = [word]\n    let joined\n    let lineNumber = 0\n    const lineHeight = 1.1 // ems\n    let tspan = text\n      .text(null)\n      .append('tspan')\n      .text(word)\n\n    while (true) {\n      word = words.pop()\n      if (!word) break\n      line.push(word)\n      joined = line.join(' ')\n      tspan.text(joined)\n      if (\n        joined.length > minChars &&\n        tspan.node().getComputedTextLength() > width\n      ) {\n        line.pop()\n        tspan.text(line.join(' '))\n        line = [word]\n        tspan = text.append('tspan').text(word)\n        lineNumber++\n      }\n    }\n\n    const initial = 0.35 - (lineNumber * lineHeight) / 2\n    const x = text.attr('x')\n    const y = text.attr('y')\n\n    text\n      .selectAll('tspan')\n      .attr('x', x)\n      .attr('y', y)\n      .attr('dy', function(d, i) {\n        return initial + i * lineHeight + 'em'\n      })\n  }\n}\n\nfunction circleMargin(current, interior, exterior) {\n  let margin = interior[0].radius - distance(interior[0], current)\n  let i\n  let m\n  for (i = 1; i < interior.length; ++i) {\n    m = interior[i].radius - distance(interior[i], current)\n    if (m <= margin) {\n      margin = m\n    }\n  }\n\n  for (i = 0; i < exterior.length; ++i) {\n    m = distance(exterior[i], current) - exterior[i].radius\n    if (m <= margin) {\n      margin = m\n    }\n  }\n  return margin\n}\n\n// compute the center of some circles by maximizing the margin of\n// the center point relative to the circles (interior) after subtracting\n// nearby circles (exterior)\nfunction computeTextCentre(interior, exterior) {\n  // get an initial estimate by sampling around the interior circles\n  // and taking the point with the biggest margin\n  const points = []\n  let i\n  for (i = 0; i < interior.length; ++i) {\n    const c = interior[i]\n    points.push({ x: c.x, y: c.y })\n    points.push({ x: c.x + c.radius / 2, y: c.y })\n    points.push({ x: c.x - c.radius / 2, y: c.y })\n    points.push({ x: c.x, y: c.y + c.radius / 2 })\n    points.push({ x: c.x, y: c.y - c.radius / 2 })\n  }\n  let initial = points[0]\n  let margin = circleMargin(points[0], interior, exterior)\n  for (i = 1; i < points.length; ++i) {\n    const m = circleMargin(points[i], interior, exterior)\n    if (m >= margin) {\n      initial = points[i]\n      margin = m\n    }\n  }\n\n  // maximize the margin numerically\n  const solution = nelderMead(\n    function(p) {\n      return -1 * circleMargin({ x: p[0], y: p[1] }, interior, exterior)\n    },\n    [initial.x, initial.y],\n    { maxIterations: 500, minErrorDelta: 1e-10 }\n  ).x\n  let ret = { x: solution[0], y: solution[1] }\n\n  // check solution, fallback as needed (happens if fully overlapped\n  // etc)\n  let valid = true\n  for (i = 0; i < interior.length; ++i) {\n    if (distance(ret, interior[i]) > interior[i].radius) {\n      valid = false\n      break\n    }\n  }\n\n  for (i = 0; i < exterior.length; ++i) {\n    if (distance(ret, exterior[i]) < exterior[i].radius) {\n      valid = false\n      break\n    }\n  }\n\n  if (!valid) {\n    if (interior.length == 1) {\n      ret = { x: interior[0].x, y: interior[0].y }\n    } else {\n      const areaStats = {}\n      intersectionArea(interior, areaStats)\n\n      if (areaStats.arcs.length === 0) {\n        ret = { x: 0, y: -1000, disjoint: true }\n      } else if (areaStats.arcs.length == 1) {\n        ret = {\n          x: areaStats.arcs[0].circle.x,\n          y: areaStats.arcs[0].circle.y\n        }\n      } else if (exterior.length) {\n        // try again without other circles\n        ret = computeTextCentre(interior, [])\n      } else {\n        // take average of all the points in the intersection\n        // polygon. this should basically never happen\n        // and has some issues:\n        // https://github.com/benfred/venn.js/issues/48#issuecomment-146069777\n        ret = getCenter(\n          areaStats.arcs.map(function(a) {\n            return a.p1\n          })\n        )\n      }\n    }\n  }\n\n  return ret\n}\n\n// given a dictionary of {setid : circle}, returns\n// a dictionary of setid to list of circles that completely overlap it\nfunction getOverlappingCircles(circles) {\n  const ret = {}\n  const circleids = []\n  for (const circleid in circles) {\n    circleids.push(circleid)\n    ret[circleid] = []\n  }\n  for (let i = 0; i < circleids.length; i++) {\n    const a = circles[circleids[i]]\n    for (let j = i + 1; j < circleids.length; ++j) {\n      const b = circles[circleids[j]]\n      const d = distance(a, b)\n\n      if (d + b.radius <= a.radius + 1e-10) {\n        ret[circleids[j]].push(circleids[i])\n      } else if (d + a.radius <= b.radius + 1e-10) {\n        ret[circleids[i]].push(circleids[j])\n      }\n    }\n  }\n  return ret\n}\n\nfunction computeTextCentres(circles, areas) {\n  const ret = {}\n  const overlapped = getOverlappingCircles(circles)\n  for (let i = 0; i < areas.length; ++i) {\n    const area = areas[i].sets\n    const areaids = {}\n    const exclude = {}\n    for (let j = 0; j < area.length; ++j) {\n      areaids[area[j]] = true\n      const overlaps = overlapped[area[j]]\n      // keep track of any circles that overlap this area,\n      // and don't consider for purposes of computing the text\n      // centre\n      for (let k = 0; k < overlaps.length; ++k) {\n        exclude[overlaps[k]] = true\n      }\n    }\n\n    const interior = []\n    const exterior = []\n    for (const setid in circles) {\n      if (setid in areaids) {\n        interior.push(circles[setid])\n      } else if (!(setid in exclude)) {\n        exterior.push(circles[setid])\n      }\n    }\n    const centre = computeTextCentre(interior, exterior)\n    ret[area] = centre\n    if (centre.disjoint && areas[i].size > 0) {\n      console.log('WARNING: area ' + area + ' not represented on screen')\n    }\n  }\n  return ret\n}\n\n// sorts all areas in the venn diagram, so that\n// a particular area is on top (relativeTo) - and\n// all other areas are so that the smallest areas are on top\nfunction sortAreas(div, relativeTo) {\n  // figure out sets that are completly overlapped by relativeTo\n  const overlaps = getOverlappingCircles(div.selectAll('svg').datum())\n  const exclude = {}\n  for (let i = 0; i < relativeTo.sets.length; ++i) {\n    const check = relativeTo.sets[i]\n    for (const setid in overlaps) {\n      const overlap = overlaps[setid]\n      for (let j = 0; j < overlap.length; ++j) {\n        if (overlap[j] == check) {\n          exclude[setid] = true\n          break\n        }\n      }\n    }\n  }\n\n  // checks that all sets are in exclude;\n  function shouldExclude(sets) {\n    for (let i = 0; i < sets.length; ++i) {\n      if (!(sets[i] in exclude)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  // need to sort div's so that Z order is correct\n  div.selectAll('g').sort(function(a, b) {\n    // highest order set intersections first\n    if (a.sets.length != b.sets.length) {\n      return a.sets.length - b.sets.length\n    }\n\n    if (a == relativeTo) {\n      return shouldExclude(b.sets) ? -1 : 1\n    }\n    if (b == relativeTo) {\n      return shouldExclude(a.sets) ? 1 : -1\n    }\n\n    // finally by size\n    return b.size - a.size\n  })\n}\n\nfunction circlePath(x, y, r) {\n  const ret = []\n  ret.push('\\nM', x, y)\n  ret.push('\\nm', -r, 0)\n  ret.push('\\na', r, r, 0, 1, 0, r * 2, 0)\n  ret.push('\\na', r, r, 0, 1, 0, -r * 2, 0)\n  return ret.join(' ')\n}\n\n// inverse of the circlePath function, returns a circle object from an svg path\nfunction circleFromPath(path) {\n  const tokens = path.split(' ')\n  return {\n    x: parseFloat(tokens[1]),\n    y: parseFloat(tokens[2]),\n    radius: -parseFloat(tokens[4])\n  }\n}\n\n/** returns a svg path of the intersection area of a bunch of circles */\nfunction intersectionAreaPath(circles) {\n  const stats = {}\n  intersectionArea(circles, stats)\n  const arcs = stats.arcs\n\n  if (arcs.length === 0) {\n    return 'M 0 0'\n  } else if (arcs.length == 1) {\n    const circle = arcs[0].circle\n    return circlePath(circle.x, circle.y, circle.radius)\n  } else {\n    // draw path around arcs\n    const ret = ['\\nM', arcs[0].p2.x, arcs[0].p2.y]\n    for (let i = 0; i < arcs.length; ++i) {\n      const arc = arcs[i]\n      const r = arc.circle.radius\n      const wide = arc.width > r\n      ret.push('\\nA', r, r, 0, wide ? 1 : 0, 1, arc.p1.x, arc.p1.y)\n    }\n    return ret.join(' ')\n  }\n}\n\nexport {\n  intersectionArea,\n  circleCircleIntersection,\n  circleOverlap,\n  circleArea,\n  distance,\n  venn,\n  greedyLayout,\n  scaleSolution,\n  normalizeSolution,\n  bestInitialLayout,\n  lossFunction,\n  disjointCluster,\n  distanceFromIntersectArea,\n  VennDiagram,\n  wrapText,\n  computeTextCentres,\n  computeTextCentre,\n  sortAreas,\n  circlePath,\n  circleFromPath,\n  intersectionAreaPath\n}\n","import { render } from \"./Bio-venn.vue?vue&type=template&id=4905268d&scoped=true\"\nimport script from \"./Bio-venn.vue?vue&type=script&lang=js\"\nexport * from \"./Bio-venn.vue?vue&type=script&lang=js\"\nscript.render = render\nscript.__scopeId = \"data-v-4905268d\"\n\nexport default script"],"sourceRoot":""}